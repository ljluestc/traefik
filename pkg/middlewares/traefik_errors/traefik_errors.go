// Package traefik_errors provides middleware for handling Traefik-generated errors.
package traefik_errors

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"

	"github.com/traefik/traefik/v3/pkg/config/dynamic"
	"github.com/traefik/traefik/v3/pkg/log"
	"github.com/traefik/traefik/v3/pkg/middlewares"
)

const (
	// TypeName is the middleware type name.
	TypeName = "TraefikErrors"
)

// TraefikErrors is a middleware that provides custom error pages for Traefik-generated errors.
type TraefikErrors struct {
	next         http.Handler
	errorPages   map[int]string
	errorHandler http.Handler
	name         string
}

// New creates a new TraefikErrors middleware.
func New(ctx context.Context, next http.Handler, config dynamic.TraefikErrors, name string) (http.Handler, error) {
	log.FromContext(middlewares.GetLoggerCtx(ctx, name, TypeName)).Debug("Creating middleware")

	errorPages := make(map[int]string)
	for strCode, path := range config.ErrorPages {
		code, err := strconv.Atoi(strCode)
		if err != nil {
			return nil, fmt.Errorf("invalid status code: %w", err)
		}

		// If path is relative, make it absolute
		if !filepath.IsAbs(path) {
			if abspath, err := filepath.Abs(path); err != nil {
				log.FromContext(ctx).Warnf("Could not make path '%s' absolute: %v", path, err)
			} else {
				path = abspath
			}
		}

		// Check if the file exists
		if _, err := os.Stat(path); err != nil {
			return nil, fmt.Errorf("error page %s does not exist: %w", path, err)
		}

		errorPages[code] = path
	}

	return &TraefikErrors{
		next:       next,
		errorPages: errorPages,
		name:       name,
	}, nil
}

func (t *TraefikErrors) GetTracingInformation() (string, string, http.Handler) {
	return t.name, TypeName, t.next
}

func (t *TraefikErrors) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	// Create a response writer wrapper to capture the status code
	crw := &captureResponseWriter{
		ResponseWriter: rw,
		headerMap:      make(http.Header),
		isTraefikError: isTraefikError(req),
	}

	t.next.ServeHTTP(crw, req)

	// If it's not a Traefik-generated error or we don't have a custom page for this status code,
	// we just return the original response
	if !crw.isTraefikError || crw.statusCode < 400 || t.errorPages[crw.statusCode] == "" {
		return
	}

	// Return the custom error page for Traefik-generated errors
	page, ok := t.errorPages[crw.statusCode]
	if !ok {
		return
	}

	file, err := os.Open(page)
	if err != nil {
		log.WithoutContext().Errorf("Failed to open error page file: %v", err)
		return
	}
	defer file.Close()

	// Reset headers and status
	for key := range crw.Header() {
		crw.Header().Del(key)
	}
	for key, values := range crw.headerMap {
		for _, value := range values {
			crw.Header().Add(key, value)
		}
	}

	rw.WriteHeader(crw.statusCode)

	// Copy the custom error page content to the response
	_, err = io.Copy(rw, file)
	if err != nil {
		log.WithoutContext().Errorf("Failed to copy error page content: %v", err)
	}
}

// captureResponseWriter is a wrapper for http.ResponseWriter that captures the status code
type captureResponseWriter struct {
	http.ResponseWriter
	headerMap      http.Header
	statusCode     int
	isTraefikError bool
}

func (crw *captureResponseWriter) WriteHeader(statusCode int) {
	crw.statusCode = statusCode
	if !crw.isTraefikError {
		crw.ResponseWriter.WriteHeader(statusCode)
	}
}

func (crw *captureResponseWriter) Write(p []byte) (int, error) {
	if !crw.isTraefikError {
		return crw.ResponseWriter.Write(p)
	}
	return len(p), nil // Fake successful write but don't actually write
}

func (crw *captureResponseWriter) Header() http.Header {
	if !crw.isTraefikError {
		return crw.ResponseWriter.Header()
	}
	return crw.headerMap
}

// isTraefikError determines if an error was generated by Traefik itself
// This is a heuristic: we look for specific request attributes set by Traefik when it generates errors
func isTraefikError(req *http.Request) bool {
	// Check for internal Traefik error flag
	// The specific implementation would depend on how Traefik marks its internal errors
	// This is a placeholder for the actual implementation
	return req.Header.Get("X-Traefik-Internal-Error") != "" ||
		req.Context().Value("traefikGeneratedError") != nil
}

const (
	// TypeName is the middleware type name.
	TypeName = "TraefikErrors"
)

// TraefikErrors is a middleware that provides custom error pages for Traefik-generated errors.
type TraefikErrors struct {
	next         http.Handler
	errorPages   map[int]string
	errorHandler http.Handler
	name         string
}

// New creates a new TraefikErrors middleware.
func New(ctx context.Context, next http.Handler, config dynamic.TraefikErrors, name string) (http.Handler, error) {
	log.FromContext(middlewares.GetLoggerCtx(ctx, name, TypeName)).Debug("Creating middleware")

	errorPages := make(map[int]string)
	for strCode, path := range config.ErrorPages {
		code, err := strconv.Atoi(strCode)
		if err != nil {
			return nil, fmt.Errorf("invalid status code: %w", err)
		}

		// If path is relative, make it absolute
		if !filepath.IsAbs(path) {
			if abspath, err := filepath.Abs(path); err != nil {
				log.FromContext(ctx).Warnf("Could not make path '%s' absolute: %v", path, err)
			} else {
				path = abspath
			}
		}

		// Check if the file exists
		if _, err := os.Stat(path); err != nil {
			return nil, fmt.Errorf("error page %s does not exist: %w", path, err)
		}

		errorPages[code] = path
	}

	return &TraefikErrors{
		next:       next,
		errorPages: errorPages,
		name:       name,
	}, nil
}

func (t *TraefikErrors) GetTracingInformation() (string, string, http.Handler) {
	return t.name, TypeName, t.next
}

func (t *TraefikErrors) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	// Create a response writer wrapper to capture the status code
	crw := &captureResponseWriter{
		ResponseWriter: rw,
		headerMap:      make(http.Header),
		isTraefikError: isTraefikError(req),
	}

	t.next.ServeHTTP(crw, req)

	// If it's not a Traefik-generated error or we don't have a custom page for this status code,
	// we just return the original response
	if !crw.isTraefikError || crw.statusCode < 400 || t.errorPages[crw.statusCode] == "" {
		return
	}

	// Return the custom error page for Traefik-generated errors
	page, ok := t.errorPages[crw.statusCode]
	if !ok {
		return
	}

	file, err := os.Open(page)
	if err != nil {
		log.WithoutContext().Errorf("Failed to open error page file: %v", err)
		return
	}
	defer file.Close()

	// Reset headers and status
	for key := range crw.Header() {
		crw.Header().Del(key)
	}
	for key, values := range crw.headerMap {
		for _, value := range values {
			crw.Header().Add(key, value)
		}
	}

	rw.WriteHeader(crw.statusCode)

	// Copy the custom error page content to the response
	_, err = io.Copy(rw, file)
	if err != nil {
		log.WithoutContext().Errorf("Failed to copy error page content: %v", err)
	}
}

// captureResponseWriter is a wrapper for http.ResponseWriter that captures the status code
type captureResponseWriter struct {
	http.ResponseWriter
	headerMap      http.Header
	statusCode     int
	isTraefikError bool
}

func (crw *captureResponseWriter) WriteHeader(statusCode int) {
	crw.statusCode = statusCode
	if !crw.isTraefikError {
		crw.ResponseWriter.WriteHeader(statusCode)
	}
}

func (crw *captureResponseWriter) Write(p []byte) (int, error) {
	if !crw.isTraefikError {
		return crw.ResponseWriter.Write(p)
	}
	return len(p), nil // Fake successful write but don't actually write
}

func (crw *captureResponseWriter) Header() http.Header {
	if !crw.isTraefikError {
		return crw.ResponseWriter.Header()
	}
	return crw.headerMap
}

// isTraefikError determines if an error was generated by Traefik itself
// This is a heuristic: we look for specific request attributes set by Traefik when it generates errors
func isTraefikError(req *http.Request) bool {
	// Check for internal Traefik error flag
	// The specific implementation would depend on how Traefik marks its internal errors
	// This is a placeholder for the actual implementation
	return req.Header.Get("X-Traefik-Internal-Error") != "" ||
		req.Context().Value("traefikGeneratedError") != nil
}
