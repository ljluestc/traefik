package traefik_errors

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"net"
	"net/http"
	"strings"
)

// responseRecorder captures the status code and other information from the response
type responseRecorder struct {
	http.ResponseWriter
	statusCode      int
	body            *bytes.Buffer
	backendAttempted bool
	headerWritten   bool
}

// newResponseRecorder creates a new recorder
func newResponseRecorder(rw http.ResponseWriter) *responseRecorder {
	return &responseRecorder{
		ResponseWriter:   rw,
		statusCode:       http.StatusOK,
		body:             &bytes.Buffer{},
		backendAttempted: false,
	}
}

// WriteHeader captures the status code
func (r *responseRecorder) WriteHeader(statusCode int) {
	if !r.headerWritten {
		r.statusCode = statusCode
		r.headerWritten = true
	}
}

// Write captures the body
func (r *responseRecorder) Write(buf []byte) (int, error) {
	if r.statusCode == 0 {
		r.statusCode = http.StatusOK
	}
	return r.body.Write(buf)
}

// Flush implements http.Flusher
func (r *responseRecorder) Flush() {
	if flusher, ok := r.ResponseWriter.(http.Flusher); ok {
		flusher.Flush()
	}
}

// Hijack implements http.Hijacker
func (r *responseRecorder) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	if hijacker, ok := r.ResponseWriter.(http.Hijacker); ok {
		return hijacker.Hijack()
	}
	return nil, nil, fmt.Errorf("responseRecorder doesn't implement http.Hijacker")
}

// SetBackendAttempted marks that a backend request was attempted
func (r *responseRecorder) SetBackendAttempted(attempted bool) {
	r.backendAttempted = attempted
}

// IsTraefikError determines if this error was generated by Traefik
func (r *responseRecorder) IsTraefikError() bool {
	return IsTraefikGeneratedError(r.statusCode, r.backendAttempted)
}

// StatusMatches checks if the status code matches any of the provided status codes or ranges
func StatusMatches(statusCode int, statusList []string) bool {
	statusCodeStr := fmt.Sprintf("%d", statusCode)
	
	for _, status := range statusList {
		if status == statusCodeStr {
			return true
		}
		if strings.Contains(status, "-") {
			parts := strings.Split(status, "-")
			if len(parts) == 2 {
				start, end := 0, 0
				fmt.Sscanf(parts[0], "%d", &start)
				fmt.Sscanf(parts[1], "%d", &end)
				if statusCode >= start && statusCode <= end {
					return true
				}
			}
		}
	}
	
	return false
}

// WithTraefikErrorFlag adds a flag to the context indicating this is a Traefik-generated error
func WithTraefikErrorFlag(ctx context.Context) context.Context {
	return context.WithValue(ctx, "traefik.generated.error", true)
}

// HasTraefikErrorFlag checks if the context indicates a Traefik-generated error
func HasTraefikErrorFlag(ctx context.Context) bool {
	if val, ok := ctx.Value("traefik.generated.error").(bool); ok {
		return val
	}
	return false
}
