// Package traefik_errors provides a middleware to display custom error pages for errors generated by Traefik.
package traefik_errors

import (
	"bufio"
	"context"
	"fmt"
	"net"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/traefik/traefik/v3/pkg/config/dynamic"
	"github.com/traefik/traefik/v3/pkg/log"
	"github.com/traefik/traefik/v3/pkg/middlewares/accesslog"
	"github.com/traefik/traefik/v3/pkg/tracing"
)

// traefik_errors is a middleware that provides custom error pages for Traefik-generated errors.
type traefik_errors struct {
	name        string
	next        http.Handler
	errHandler  http.Handler
	errPage     *dynamic.TraefikErrors
	trafficType string
}

// New creates a new traefik_errors middleware.
func New(ctx context.Context, next http.Handler, errPage dynamic.TraefikErrors, errHandler http.Handler, name string) (http.Handler, error) {
	log.FromContext(ctx).Debug("Creating traefik_errors middleware")

	// Validate configuration
	if len(errPage.Status) == 0 {
		return nil, fmt.Errorf("status codes are required for traefik_errors middleware")
	}

	if errHandler == nil && (errPage.Service == "" || errPage.Query == "") {
		return nil, fmt.Errorf("either service and query or a custom handler are required for traefik_errors middleware")
	}

	return &traefik_errors{
		name:       name,
		next:       next,
		errHandler: errHandler,
		errPage:    &errPage,
	}, nil
}

func (te *traefik_errors) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	recorder := newTraefikErrorRecorder(rw, te.errPage.Status)

	// Capture request IP and headers before forwarding the request
	recorder.remoteIP = req.RemoteAddr
	utils.CopyHeaders(recorder.requestHeaders, req.Header)

	te.next.ServeHTTP(recorder, req)

	// Check if this was a Traefik-generated error
	if recorder.isTraefikError && recorder.code >= 400 {
		// This is a Traefik-generated error, serve our custom error page
		logger := log.FromContext(req.Context())
		logger.Debugf("Serving Traefik error page for status %d", recorder.code)

		// Log detailed error information for debugging
		logger.WithField("ip", recorder.remoteIP).
			WithField("headers", logSafeHeaders(recorder.requestHeaders)).
			WithField("status", recorder.code).
			WithField("method", req.Method).
			WithField("path", req.URL.Path).
			Debug("Traefik error details")

		query := replaceStatus(te.errPage.Query, recorder.code)
		pageReq, err := newRequest(te.errPage, query, req)
		if err != nil {
			logger.Errorf("Error creating error page request: %v", err)
			rw.WriteHeader(recorder.code)
			_, _ = rw.Write([]byte(http.StatusText(recorder.code)))
			return
		}

		// Add tracing context
		if te.trafficType != "" {
			tracing.SetTrafficType(pageReq.Context(), te.trafficType)
		}

		// Add error info to request context
		pageReq = pageReq.WithContext(context.WithValue(pageReq.Context(), "traefik.error.status", recorder.code))
		pageReq = pageReq.WithContext(context.WithValue(pageReq.Context(), "traefik.error.message", http.StatusText(recorder.code)))

		// Store detailed error information in context for the health API
		errorDetails := ErrorDetails{
			StatusCode: recorder.code,
			Status:     http.StatusText(recorder.code),
			Method:     req.Method,
			Host:       req.Host,
			Path:       req.URL.Path,
			IP:         recorder.remoteIP,
			Headers:    headerMapToString(recorder.requestHeaders),
			Time:       time.Now().UTC(),
		}
		pageReq = pageReq.WithContext(context.WithValue(pageReq.Context(), "traefik.error.details", errorDetails))

		if te.errHandler != nil {
			// Use the pre-built error handler
			te.errHandler.ServeHTTP(newTraefikErrorResponseWriter(rw, recorder.code), pageReq)
		} else {
			// In case the error handler wasn't built yet (shouldn't happen)
			rw.WriteHeader(recorder.code)
			_, _ = rw.Write([]byte(http.StatusText(recorder.code)))
		}
		return
	}

	// If it wasn't a Traefik error or wasn't an error at all, just copy the response
	utils.CopyHeaders(rw.Header(), recorder.Header())
	rw.WriteHeader(recorder.code)
	_, _ = rw.Write(recorder.body.Bytes())
}

// headerMapToString converts http.Header to a formatted string
func headerMapToString(headers http.Header) string {
	var result strings.Builder
	for name, values := range headers {
		for _, value := range values {
			result.WriteString(name)
			result.WriteString(": ")
			result.WriteString(value)
			result.WriteString("\n")
		}
	}
	return result.String()
}

// logSafeHeaders returns headers in a format suitable for logging
// This can be enhanced with filtering sensitive headers if needed
func logSafeHeaders(headers http.Header) map[string]string {
	result := make(map[string]string)
	for name, values := range headers {
		// Skip sensitive headers or filter their values if needed
		if strings.ToLower(name) == "authorization" {
			result[name] = "[FILTERED]"
		} else if len(values) > 0 {
			result[name] = values[0]
		}
	}
	return result
}

// isTraefikGeneratedError determines if an error status code was generated by Traefik itself
// This is a simplified implementation - in a real-world case, you'd need to use more
// sophisticated detection methods, possibly using context or headers to flag errors
// generated by Traefik vs. ones from upstream services.
func isTraefikGeneratedError(code int) bool {
	// For now, we consider these status codes as typically generated by Traefik:
	// - 404: When route is not found
	// - 502: Bad Gateway (when backend is unreachable)
	// - 503: Service Unavailable (when no backend is available)
	// - 504: Gateway Timeout (when backend times out)
	return code == http.StatusNotFound ||
		code == http.StatusBadGateway ||
		code == http.StatusServiceUnavailable ||
		code == http.StatusGatewayTimeout
}

// replaceStatus replaces the status code placeholder in the query.
func replaceStatus(query string, status int) string {
	return strings.Replace(query, "{status}", strconv.Itoa(status), -1)
}

// newRequest creates a new request to the error handler.
func newRequest(errPage *dynamic.TraefikErrors, query string, origReq *http.Request) (*http.Request, error) {
	u := url.URL{
		Scheme:   "http",
		Host:     errPage.Service,
		Path:     query,
		RawQuery: "", // No query parameters for now
	}

	req, err := http.NewRequestWithContext(origReq.Context(), http.MethodGet, u.String(), nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	// Copy headers from original request
	utils.CopyHeaders(req.Header, origReq.Header)

	// Set X-Forwarded headers
	req.Header.Set("X-Forwarded-For", origReq.RemoteAddr)
	req.Header.Set("X-Forwarded-Proto", "http") // Simplified - should use original scheme
	req.Header.Set("X-Forwarded-Host", origReq.Host)
	req.Header.Set("X-Forwarded-Uri", origReq.RequestURI)
	req.Header.Set("X-Forwarded-Method", origReq.Method)
package traefik_errors

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/traefik/traefik/v3/pkg/config/dynamic"
	"github.com/traefik/traefik/v3/pkg/log"
)

// Handler is a middleware that serves custom error pages for Traefik-generated errors
type Handler struct {
	name           string
	next           http.Handler
	errorHandler   http.Handler
	configuration  dynamic.TraefikErrors
}

// New creates a new Handler
func New(ctx context.Context, next http.Handler, config dynamic.TraefikErrors, errorHandler http.Handler, name string) (http.Handler, error) {
	logger := log.FromContext(ctx)
	logger.Debug().Str("middleware", name).Msg("Creating traefik_errors middleware")
	
	if len(config.Status) == 0 {
		return nil, fmt.Errorf("status codes are required for traefik_errors middleware")
	}
	
	if errorHandler == nil && (config.Service == "" || config.Query == "") {
		return nil, fmt.Errorf("service and query are required when no error handler is provided")
	}
	
	return &Handler{
		name:           name,
		next:           next,
		errorHandler:   errorHandler,
		configuration:  config,
	}, nil
}

// ServeHTTP implements http.Handler
func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	recorder := newResponseRecorder(rw)
	
	// If we're accessing a backend, set the flag
	if req.Header.Get("X-Forwarded-For") != "" {
		recorder.SetBackendAttempted(true)
	}
	
	// Call the next handler
	h.next.ServeHTTP(recorder, req)
	
	// Check if this is a Traefik-generated error that matches our configuration
	if recorder.IsTraefikError() && StatusMatches(recorder.statusCode, h.configuration.Status) {
		// This is a Traefik-generated error we want to handle
		logger := log.FromContext(req.Context())
		logger.Debug().
			Str("middleware", h.name).
			Int("status", recorder.statusCode).
			Bool("backendAttempted", recorder.backendAttempted).
			Msg("Handling Traefik-generated error")
		
		// If we have an error handler, use it
		if h.errorHandler != nil {
			// Prepare the error page request
			errorPageURL := h.buildErrorPageURL(recorder.statusCode)
			if errorPageURL == "" {
				// If no error page URL can be built, just return the original response
				h.writeOriginalResponse(rw, recorder)
				return
			}
			
			errorReq, err := h.createErrorRequest(req, errorPageURL, recorder.statusCode)
			if err != nil {
				logger.Error().Err(err).Msg("Failed to create error page request")
				h.writeOriginalResponse(rw, recorder)
				return
			}
			
			// Mark this as an internal error request to avoid infinite loops
			errorReq = errorReq.WithContext(WithTraefikErrorFlag(errorReq.Context()))
			
			// Serve the error page
			h.errorHandler.ServeHTTP(rw, errorReq)
			return
		}
		
		// If we don't have an error handler, return the original response
		h.writeOriginalResponse(rw, recorder)
		return
	}
	
	// Not a Traefik-generated error or doesn't match our configuration
	// Just pass through the original response
	h.writeOriginalResponse(rw, recorder)
}

// buildErrorPageURL builds the URL for the error page
func (h *Handler) buildErrorPageURL(statusCode int) string {
	if h.configuration.Query == "" {
		return ""
	}
	
	// Replace {status} placeholder with the actual status code
	return strings.Replace(h.configuration.Query, "{status}", strconv.Itoa(statusCode), -1)
}

// createErrorRequest creates a new request for the error page
func (h *Handler) createErrorRequest(origReq *http.Request, errorPath string, statusCode int) (*http.Request, error) {
	u := url.URL{
		Scheme: "http",
		Host:   h.configuration.Service,
		Path:   errorPath,
	}
	
	errorReq, err := http.NewRequestWithContext(origReq.Context(), http.MethodGet, u.String(), nil)
	if err != nil {
		return nil, fmt.Errorf("error creating error page request: %w", err)
	}
	
	// Copy headers from the original request
	for k, v := range origReq.Header {
		errorReq.Header[k] = v
	}
	
	// Add X-Forwarded headers
	errorReq.Header.Set("X-Forwarded-Method", origReq.Method)
	errorReq.Header.Set("X-Forwarded-Proto", origReq.URL.Scheme)
	errorReq.Header.Set("X-Forwarded-Host", origReq.Host)
	errorReq.Header.Set("X-Forwarded-Uri", origReq.RequestURI)
	errorReq.Header.Set("X-Forwarded-For", origReq.RemoteAddr)
	
	// Add information about the error
	errorReq.Header.Set("X-Traefik-Error-Status", strconv.Itoa(statusCode))
	errorReq.Header.Set("X-Traefik-Error-Message", http.StatusText(statusCode))
	
	return errorReq, nil
}

// writeOriginalResponse writes the recorded response to the original ResponseWriter
func (h *Handler) writeOriginalResponse(rw http.ResponseWriter, recorder *responseRecorder) {
	// Copy headers
	for k, v := range recorder.Header() {
		rw.Header()[k] = v
	}
	
	// Write status code
	if !recorder.headerWritten {
		rw.WriteHeader(recorder.statusCode)
	} else {
		// If headers were already written, we can still set the status code
		if hijacker, ok := rw.(http.Hijacker); ok {
			conn, _, err := hijacker.Hijack()
			if err == nil {
				defer conn.Close()
				// Write a basic HTTP response with the status code
				statusLine := fmt.Sprintf("HTTP/1.1 %d %s\r\n", recorder.statusCode, http.StatusText(recorder.statusCode))
				conn.Write([]byte(statusLine))
				// Write headers
				for k, v := range recorder.Header() {
					for _, val := range v {
						conn.Write([]byte(fmt.Sprintf("%s: %s\r\n", k, val)))
					}
				}
				// End headers
				conn.Write([]byte("\r\n"))
				// Write body
				conn.Write(recorder.body.Bytes())
				return
			}
		}
	}
	
	// Write body
	if recorder.body.Len() > 0 {
		rw.Write(recorder.body.Bytes())
	}
}
	// Add traefik error info
	req.Header.Set("X-Traefik-Error-Status", strconv.Itoa(status))

	return req, nil
}

// traefikErrorRecorder captures the response status code and body.
type traefikErrorRecorder struct {
	HeaderMap      http.Header
	code           int
	body           *bytes.Buffer
	isTraefikError bool
	statusCodes    []string
	requestHeaders http.Header
	remoteIP       string
}

func newTraefikErrorRecorder(rw http.ResponseWriter, statusCodes []string) *traefikErrorRecorder {
	return &traefikErrorRecorder{
		HeaderMap:      make(http.Header),
		code:           http.StatusOK,
		body:           &bytes.Buffer{},
		statusCodes:    statusCodes,
		requestHeaders: make(http.Header),
	}
}

func (r *traefikErrorRecorder) Header() http.Header {
	return r.HeaderMap
}

func (r *traefikErrorRecorder) WriteHeader(statusCode int) {
	r.code = statusCode

	// Check if this status code matches our config and is a Traefik error
	if isTraefikGeneratedError(statusCode) && contains(r.statusCodes, statusCode) {
		r.isTraefikError = true
	}
}

func (r *traefikErrorRecorder) Write(buf []byte) (int, error) {
	if r.code == 0 {
		r.code = http.StatusOK
	}
	return r.body.Write(buf)
}

func (r *traefikErrorRecorder) Flush() {}

// Implementation of http.Hijacker
func (r *traefikErrorRecorder) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	return nil, nil, fmt.Errorf("hijacking not supported")
}

// Contains checks if a status code matches any of the configured codes
func contains(statusCodes []string, statusCode int) bool {
	for _, code := range statusCodes {
		if code == strconv.Itoa(statusCode) {
			return true
		}
		if strings.Contains(code, "-") {
			parts := strings.Split(code, "-")
			if len(parts) == 2 {
				start, errStart := strconv.Atoi(parts[0])
				end, errEnd := strconv.Atoi(parts[1])
				if errStart == nil && errEnd == nil && statusCode >= start && statusCode <= end {
					return true
				}
			}
		}
	}
	return false
}

// traefikErrorResponseWriter is a custom response writer that preserves the status code.
type traefikErrorResponseWriter struct {
	http.ResponseWriter
	code int
}

func newTraefikErrorResponseWriter(rw http.ResponseWriter, code int) *traefikErrorResponseWriter {
	return &traefikErrorResponseWriter{ResponseWriter: rw, code: code}
}

func (r *traefikErrorResponseWriter) WriteHeader(statusCode int) {
	// Always use the original error code, not the one from the error page
	r.ResponseWriter.WriteHeader(r.code)
}
